<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
//			alert(1);

		</script>
		<script type="text/javascript" src="js/hehe.js"></script>
		<link rel="stylesheet" type="text/css" href=""/>
	</head>
	<body>
	<pre>	
		<span id ="spandate"></span>
			<script>
				
				var date ;
				
				var count= 0;
				var timeout = setInterval(haha,5000);
				function haha(){
					
					console.log(count);
					count++;
					if(count>0){
						clearInterval(timeout);
					}
					
				}
				
//				getTime();
//				var intvaltime = setTimeout(getTime,1000) ;
//				function getTime(){
//					var span = document.getElementById("spandate");
//					date = new Date();
//					var times = date.getHours()+":"+date.getMinutes()+":"+date.getSeconds();
//					 span.innerHTML= times;
//					 intvaltime = setTimeout(getTime,1000) ;
////						getTime();
//				}
				//getTime();
				//var intvaltime = setTimeout(getTime,1000) ;
				//计时器的使用方法，互相替代的方法
			</script>
		
		
		<button id ="hehe" onclick="clearInterval(intvaltime)" >dianwo</button>
		<!--<a href="javascript:void(0)">haha</a>-->
		<script>
//			alert(1);
			document.write("<b>hehehe</b>");
			document.getElementById("hehe").innerHTML="<b>hehehe</b>";
			document.write("<b>hehehe</b>");
			
		</script>
		基于对象！=面向对象的语言，没有类；ECMA6：提供了Class ，extend (大部分浏览器，支持工具写)
		基本数据类型：
			数字类型：
				10,8,16；
				不分浮点和正数
				特殊值：
					NaN
					Infinity
			字符类型
				不区分字符串和字符 ，单引号和双引号都行；  " xxxxx  ' ' xxxx"
			布尔类型
				true false  (特别狠的隐式转换)
			未定义类型
				undifined
		复合数据类型：
			对象：
				系统对象：
						api:Number(包装类)
							String
							Boolean
							Math
							Date
							数组：Array
					函数：function；
				自定义对象：
				
			特殊值类型：null
			
			
		js对象只有六种：
		数字，字符串，布尔，对象，undefined，null；
		
		动态语言+弱类型语言
		var 变量名；
		<!--let 变量名; ECMA6-->
		var a; // a  undifined null
		
		js:区分大小写，从上往下执行，正常应该每句结尾+;
		
		
		数据类型  变量名;
		
		
		数据类型的转换? 
			显示转换：
				基本数据类型转换：
					布尔：
					    Boolean(): 
						转成true:Infinity,"true","false"，其他
						   false:undefined,null,NaN,0,空字符串，字符串长度为0
					数字：
						Number():"Infinity","true",true,false,undefined,null,NaN,空字符串，字符串长度为0,只含有数字的字符串，
							转成数字："Infinity"(Infinity),true(1),false(0),null(0),空字符串(0),字符串长度为0，只含有数字的字符串（该多少是多少）
							转成NAN："true",undefined,NaN，含有字母的数字字符串
					字符串：String():都变成对应内容的字符串
					
			隐式转换：	算数运算容易触发Number();比较（先算数在比较）和逻辑运算容易触发Boolean()，+号两边有字符串容易触发String();
						
					
		
		如何区分数据类型？
			1. typeof  数据 ： 返回类型字符串 （基本数据类型）
				问题：1.无法区分null 和Object ， 对于对象无法区分
			2. instanceof  判断前面数据是否属于后面类型， 前提是必须知道是哪种类型， 父对象和子对象无法区分
			
			<!--3. 基于原型链   可以判断所有的系统对象
			   Object.prototype.toString.apply(new Object())；
		
			4.利用构造器  区分自定义
			   obj.constructor.name-->
		ECMA5里没有常量，  ECMA6 有常量  const
		
		js 
		一个等于是赋值运算；
		两个等于 是 值 比较 ；
		三个等于 是类型和值一起比较；
		
		"字符串"-0 //如果可以强转数字 ，把字符串转成数字
		+ 有字符串全转成字符串
		
		||  和  &amp;&amp;  <!--&&--> 
		如果两边结果是布尔值，则跟java差不多；短位功能
		但是如果两边的结果不是布尔值，则会出现以下情况：
		<!--&&--> ：如果前面的值为经过隐式转换后为true ，则一定返回后面的值
				          如果前面的值经过转换后为false,则一定返回前面的值
		|| ：如果前面的值经过隐式转换后为true，则一定返回前面的值
		           如果前面的值经过隐式转换后为false，则一定返回后面的值
			
		<!--|  和&amp;  <!--&-->：直接做按位运算。
		
		判断NaN的时候需要利用isNaN函数，但是需要额外注意undifined；
		void(0);
		
		<a href="javascript:void(0);" >baidu</a>-->
		
		流程控制：
			switch语句的值可以是任意类型
			for 语句 :for循环内声明的var 变量属于全局变量，没有块变量一说；
			
			增强for循环：
			var a = [1,2,3,4,5];
				for (var i in a) {
					console.log(a[i]);
				}
			
		
		
		在网页上打印99乘法表
		
		
		函数：
			创建函数两种方式：
			函数的声明：
					function 函数名字(参数列表[没有数据类型]){
						return 1; //可以有多个return 只返回第一个	 ,代码块
					}
			函数表达式：
					var 变量(函数)名字 = function(参数列表[没有数据类型]){
						return 1;   //代码块
					}
					
					function (){ } //没有名字的函数叫匿名函数；
					匿名函数的调用
					（function(形参){代码块} (实参)）;
					
					var a =  匿名函数
					
			表达式和声明的区别：声明可以先调用后创建；表达式 不可以。
			
			<!--高级函数/回调函数：
			function f(a,b){
				return a()+b();
			};
			
			f(function(){return 1;},function(){return 2;});-->
			
			<!--通过匿名函数调用回调函数-->
			
			<!--function fa(){
				return 1;
			}
			function fb(){
				return 2;
			}
			f(fa,fb);
			-->
			
			js内置对象：所有函数都拥有一个自己的属性这个属性等于一个arguments对象
			js的常用内置函数：isNaN,isFinite,alert,parseInt,Number(),Boolean(),
			String(),parseFloat, confirm,prompt,encodeURI,decodeURI,encodeURICompotent(),
			,eval();
			setInterVal ,setTimeout			
			var a = setInterVal ;clearInterVal(a);
			
			var obj1 = new Object();
			var obj2 = {};
			对象的常见操作： . 没有则添加，有则调用
			            delete 删除属性
			            in  判断是否存在该属性 （其实有问题）
			
			var student = {
						name:"wangsong", 
						age:18,
						sex:0,
						hehe:function(){
								console.log("hehe");
							},
						teacher:{
									name:"jin",
									sex:1,
									haha:function(){
										
									}
								
								}							
						};
			<!--面向对象的23种设计模式之一：工厂模式-->			
			<!--function createStudent(name,age,teacher){
				var o = new Object();
				o.name = name;
				o.age = age;
				o.teacher = teacher;
				return o;
			}	
			var teacher1 = {teacherid:1}
			var student1 = createStudent("haha",18,teacher1);
			var student2 = createStudent("hehe",19,teacher1);
			
			--通过构造器来创建对象
			function Student(name,age,hello){
				this.name=name;
				this.age = age;
				this.hello = hello;
			}
			var s1 = new Student("haha",18,function(){console.log("hello")});
			如果this所在函数式被new的操作就等于函数名，如果是被()就等于window
			--基于原型链
			function Person(name,age){this.name=name ;this.age = age};
			Person.prototype.hello = function (){console.log("hello")};-->
			
			
			<!--高级用法-->
			
			<script>
							
							//alert(2)
			//alert(1);
			//console.log(123);
			//document.write(421);
			//输出
			//try{
			//	null.call();
			//}catch(e){
			//	console.log('错误');
			//	console.log(e.message);
			//}finally{
			//	console.log("finally");
			//}  
			//异常
			
			
			//var a = {};
			//
			//switch(a){
			//	case 1: console.log(1);
			//	break;
			//	case "2": console.log(2);
			//	break;
			//	default: console.log(3);
			//	
			//}
			//switch
			
			//js 没有块作用域
			//for(var i =1 ; i<10;i++){
			//	console.log(i );
			//}
			//
			//console.log(i);
			//作用域
			
			//var a = [1,2,3,4,5];
			//for (var i in )a {
			//	console.log(a[i]);
			//}
			//for   in
			
			//var x = {
			//	haha:1,
			//	hehe:2
			//}
			//对象
			//for(var i in x){
			//	console.log(x[i]);
			//	
			//}
			//var i =1 ;
			//do{
			//	console.log(i );
			//	i++;
			//}while( i<10);
			//循环遍历
			
			
			
			
			//function addArray(a,b){
			//	var arr = [];
			//	arr[0] = a;
			//	arr[1] = b;
			//	return arr;
			//}
			//
			//var arrout = addArray(1,2);
			//
			//function addone(a){
			//	return a+1;
			//}
			//
			//for (var i in arrout) {
			//	arrout[i] = addone(arrout[i]);
			//}
			//正常函数使用方式
			
			//function addArray(a,b,f){
			//		var arr = [];
			//		arr[0] = f(a);
			//		arr[1] = f(b);
			//		return arr;
			//}
			//var arrout = addArray(1,2,function(x){return x*x;});
			//回调函数的好处
			
			
			
			
			
			//document.write(arrout);
			
			//function defaultvalue(x,y){
			//	x = x||0; //默认值写法
			//	y = y||1;
			//	return x+y;
			//}
			//console.log(defaultvalue(2,1,3,4,5))
			//函数默认值的使用方法
			
			
			//var a = function (){
			//	
			//	for (var i in arguments) {
			//		console.log(arguments[i]);
			//	}
			//	
			//}
			//
			//a(1,2,3,4,5);
			//函数的默认属性arguments数组的使用方式，和函数随意传入参数的调用方式
			
			
			
			//
			//function haha(a,b){
			//	console.log("hehe");
			//}
			
			//function hehe(){
			//	console.log(1); 
			//	return function (){console.log("2")};
			//}
			//hehe()();
			//函数返回函数的写法
			
			
			
			//var good= function (){
			//	console.log("你好");
			//	return function(){
			//		console.log("阿内哈赛有"); 
			//	}
			//}
			//函数自我更新的方法
			//
			
			
			//good = good();
			//good();
			//good();
			
			//function haha(x){
			//	var hehe = function(y){
			//		 console.log(y+1);
			//	}
			//	return hehe(x);
			//	
			//}
			//
			//haha(1);
			//hehe(1);
			//函数的私有化方法
			
			//闭包

				
			</script>
</pre>			
	</body>

</html>
	